const dotenv = require('dotenv');

/**
 * A dictionary of environmental variables.
 * @typedef {Object.<string, string>} EnvList
 *
 * @todo Upgrade to a class that implements env.LIST_PROTO below.
 */

/**
 * A descriptive environment context that stores the definitions for
 * environmental variables by their source, as well as any errors that
 * have been generated while compiling them.
 * @typedef {Object} EnvContext
 * @property {EnvList} defaults - Default environmental variables that
 *                     are overriden by all other explicity set
 *                     environmental variables.
 * @property {EnvList} constants - Constant environmental variables that
 *                     can not be overriden.
 * @property {EnvList} process - The content of process.env as of the last
 *                     call to _resetCtx.
 * @property {EnvList} dotenv - All environmental variables loaded by the
 *                     dotenv module.
 * @property {Object}  errors - A depository for errors generated when
 *                     loading the environment.
 */

/**
 * The memoized environment context that we mutate and share.
 * @type {EnvContext}
 */
const ctx = {
  defaults: {},
  constants: {},
  process: {},
  dotenv: {},
  errors: {},
};

/**
 * Generates a set of environmental variables from the current context,
 * after applying all passed options. If a set of names we want to ensure
 * exist are passed, will apply these after the list is generated.
 * @param {EnvOptions} [options=env.DEFAULT_OPTS]
 * @returns {EnvList} The reset, newly-generated environmental variables.
 */
function env(options = {}) {
  const opts = Object.assign(env.DEFAULT_OPTS, options);
  env.defaults(opts.defaults);
  env.constants(opts.constants);
  if (opts.dotenv) {
    env.dotenv();
  }
  const obj = env._generateFromCtx();
  obj.missingReturnValue(opts.missingReturnValue);
  if (Array.isArray(opts.ensure) && opts.ensure.length) {
    env.ensure(opts.ensure, Object.keys(obj));
  }
  return obj;
}

/**
 * Options for calls to generate a new context.
 * @typedef {Object} EnvOptions
 * @property {boolean}  dotenv - Whether or not to run a dotenv config
 *                      load.
 * @property {EnvList}  defaults - A list of default environmental
 *                      variables.
 * @property {EnvList}  constants - A list of constant environmental
 *                      variables.
 * @property {string[]} ensure - A list environmental variable names that
 *                      must exist in the context, or we exit the program.
 * @property {*}        missingReturnValue - The value that is returned
 *                      when we call EnvList.get() on a missing value.
 */

/**
 * The default options passed to calls that generate a new context.
 * @type {EnvOptions}
 * @constant
 * @default
 */
env.DEFAULT_OPTS = {
  dotenv: true,
  constants: {},
  defaults: {},
  ensure: [],
  missingReturnValue: undefined,
};

/**
 * @typedef {Object} DotenvResult
 * @property {EnvList} dotenv - The list of environmental variables
 *                     loaded, if any, from the .env file.
 * @property {Error}   error - Any error (usually, missing .env file)
 *                     generated by running dotenv.config().
 */

/**
 * Loads variables from a .env file. Uses the standard modulen "dotenv",
 * but keeps the process.env free of the variables that are loaded,
 * adding them to the internal ctx.dotenv list. Any errors that are
 * generated are added to ctx.errors.dotenv (currently the only source
 * of errors in the context).
 * @returns {DotenvResult}
 */
env.dotenv = function() {
  // Ensure we have a copy of the current process.env, then run dotenv.
  ctx.process = Object.assign({}, process.env);
  const { parsed, error } = dotenv.config();

  // Identify what vars (if any) were appended by dotenv, and add to ctx.
  if (parsed) {
    Object.keys(parsed).forEach(prop => {
      if (!Object.prototype.hasOwnProperty.call(ctx.process, prop)) {
        ctx.dotenv[prop] = parsed[prop];
      }
    });
  }

  // Attach any errors
  if (error) {
    ctx.errors = Object.assign(ctx.errors, { dotenv: { error } });
  }

  // Restore the clean, pre-dotenv process.env
  process.env = ctx.process;
  return { dotenv: ctx.dotenv, error: error };
};

/**
 * Set the context's default environmental variables.
 * @param {EnvList} defaults - The new default environmental variables to
 *                  add/update.
 * @return {EnvList} The updated, complete list of default environmental
 *                   variables.
 */
env.defaults = function(defaults = {}) {
  ctx.defaults = Object.assign(ctx.defaults, defaults);
  return ctx.defaults;
};

/**
 * Set the context's constant environmental variables.
 * @param {EnvList} constants - The new constant environmental variables
 *                  to add/update.
 * @return {EnvList} The updated, complete list of constant environmental
 *                   variables.
 */
env.constants = function(constants = {}) {
  ctx.constants = Object.assign(ctx.constants, constants);
  return ctx.constants;
};

/**
 * Clears out the context and regenerates it according to the given
 * options.
 * @param {EnvOptions} [options=env.DEFAULT_OPTS]
 * @returns {EnvList} The reset, newly-generated environmental variables.
 */
env.reset = function(options = {}) {
  const opts = Object.assign(env.DEFAULT_OPTS, options);
  env._resetCtx();
  return env(opts);
};

/**
 * Ensures that some variable or set of variables are defined in the
 * current context. Allows a list of defined variables to be passed, as
 * well as options that define what happens when there is a missing
 * variable. By default a miss will exit the process with an exit value
 * of 1.
 * @param {string[]} [expected=[]] - The list of variable names we expect
 *                   to have been defined.
 * @param {string[]} actual - If passed, this is the list of defined
 *                   variable names we check against (instead of those
 *                   defined in the current context).
 * @param {Object}   opts - Options.
 * @param {boolean}  [opts.silent=false] - Whether or not to log missing
 *                   variable names.
 * @param {boolean}  [opts.exitOnMiss=true] - Whether or not to exit the
 *                   process if any names are missing.
 * @returns {boolean} True if all the expected variables are defined,
 *                    false otherwise. Only runs if true or if the
 *                    exitOnMiss option is set to false.
 *
 * @todo Add an option to throwOnMiss, that collects the error messages
 *       and then throws an error at the end of the function.
 */
env.ensure = function(
  expected = [],
  actual,
  opts = { silent: false, exitOnMiss: true }
) {
  if (typeof actual === 'undefined') {
    actual = Object.keys(env._generateFromCtx());
  }

  let missing = false;
  expected.forEach(variable => {
    if (!actual.includes(variable)) {
      if (!opts.silent) {
        console.error(`[ERR] missing required env var {${variable}}`);
      }
      missing = true;
    }
  });

  if (missing && opts.exitOnMiss) {
    process.exit(1);
  }

  return !missing;
};

/**
 * A thin wrapper around env.ensure() that silences output and forces a
 * return value.
 * @param {string[]} [expected=[]] - The list of variable names we expect
 *                   to have been defined.
 * @returns {boolean} True if all the expected variables are defined,
 *                    false otherwise.
 */
env.check = function(expected = []) {
  return env.ensure(expected, undefined, { silent: true, exitOnMiss: false });
};

/**
 * A basic getter for the internal context "ctx" value.
 * @returns {EnvContext}
 */
env.ctx = function() {
  return ctx;
};

/**
 * Resets the state of the context.
 * @protected
 */
env._resetCtx = function() {
  ctx.defaults = {};
  ctx.constants = {};
  ctx.dotenv = {};
  ctx.process = Object.assign({}, process.env);
  ctx.errors = {};
};

/**
 * The prototype for all EnvList objects. Allows us to dereference variables
 * by name and control the value that is returned when the variable does not
 * exist.
 * @constant
 * @property {Object} _values - A basic object/dict version of the EnvList.
 * @property {*}      _missValue - The value returned on a miss when
 *                    calling EnvList.get().
 * @method missingReturnValue(<*>) - Sets the missing return value.
 * @method get(<string>) - Accesses the values dict (essentially a copy
 *         of the EnvList) and returns the dereferenced variable, or the
 *         _missValue if not found.
 *
 * @todo Turn this into a class definition for EnvList (replace typedef
 *       above).
 *
 * @example
 *     const envvars = env({ constants: { USERNAME: 'starbuck' } });
 *     envvars.missingReturnValue('n/a');
 *     envvars.get('USERNAME')
 *     // => 'starbuck'
 *     envvars.get('PASSWORD')
 *     // => 'n/a'
 *     envvars.PASSWORD
 *     // => undefined
 *
 * @example <caption>You can pass a missing return value on generation:</caption>
 *     const envvars = env({
 *       constants: { USERNAME: 'starbuck' },
 *       missingReturnValue: 'n/a',
 *     });
 *     envvars.get('PASSWORD')
 *     // => 'n/a'
 */
env.LIST_PROTO = {
  _values: {},
  _missValue: undefined,
  get: function(name) {
    if (!Object.prototype.hasOwnProperty.call(this._values, name)) {
      return this._missValue;
    }
    return this._values[name];
  },
  missingReturnValue: function(value = null) {
    this._missValue = value;
  },
};

/**
 * Merge the environmental variables in the context together into a
 * single environmental object. Adds a prototype to the object with a
 * few helper functions (TODO).
 * @protected
 */
env._generateFromCtx = function() {
  const values = Object.assign(
    {},
    ctx.defaults,
    ctx.dotenv,
    ctx.process,
    ctx.constants
  );
  const proto = { ...env.LIST_PROTO, _values: values };
  return Object.assign(Object.create(proto), values);
};

// Load the current state of process.env.
env._resetCtx();

module.exports = env;
